# Development Workflow Rules

## Dev Server Management
- When the dev server port is in use, try alternative ports (5176, 5177, etc.)
- Always verify which workspace a running dev server belongs to before assuming changes are visible
- Check the `cwd` (current working directory) of running processes when debugging

## Troubleshooting Steps
- For visual changes not appearing: suggest hard refresh (Cmd+Shift+R / Ctrl+Shift+R)
- Browser caching is a common cause of "changes not visible" issues
- Before concluding a change failed, verify the correct server is running for this workspace

## Communication Patterns
- When making visual/styling changes, explicitly state what changed and the file/line number
- After visual changes, offer to adjust if styling intensity needs tweaking
- Guide users through troubleshooting steps to empower self-resolution

## TypeScript Patterns
- **Type-only imports**: Use `import type { MyType }` for types when using `verbatimModuleSyntax` to avoid runtime import overhead and build failures
  - Common types requiring `import type`: `ReactNode`, `MetricConfig`, `DragEndEvent`, `VercelRequest`, `VercelResponse`
  - Build will fail if regular imports are used for types with `verbatimModuleSyntax` enabled
- **Non-null assertions**: Use `process.env.VAR_NAME!` in serverless functions where env vars are guaranteed to exist
- **Strict typing for API responses**: Define interfaces for all API response shapes in `src/types/`

## React Patterns Used in This Codebase
- Conditional rendering: `condition ? (...) : (...)` for show/hide
- NavLink with automatic `.active` class styling for navigation
- NavLink `end` prop: Use on parent routes (e.g., `/dashboard`) to prevent active state on child routes
- useState for toggles: Manage expanded/collapsed states (e.g., `channelsExpanded`, `insightsExpanded`)
- useEffect for data fetching on component mount
- useEffect for side effects: Manage body overflow when mobile nav is open, close mobile nav on route changes
- useLocation for route change triggers: Detect route changes to trigger side effects (e.g., closing mobile nav)
- Array.reduce() for aggregating campaign statistics
- `collapsed` prop propagation: Pass down to child components for consistent collapsed sidebar behavior
- Flexbox for sidebar and navigation layouts
- `overflow-y: auto` for scrollable navigation content
- Dynamic class toggling: Classes like `sidebar-collapsed`, `expanded`, `mobile-open` toggled in `.tsx`, defined in `.css`
- **useSearchParams cleanup**: When reading from `useSearchParams` for initial state, clear the params after consumption to prevent stale data on subsequent renders:
  ```tsx
  const [searchParams, setSearchParams] = useSearchParams();
  useEffect(() => {
    const initialValue = searchParams.get('value');
    if (initialValue) {
      // Use the value...
      searchParams.delete('value');
      setSearchParams(searchParams, { replace: true });
    }
  }, []);
  ```

## SVG Icon Conventions
- Use inline SVGs for icons (not icon fonts or separate image files)
- Standard attributes: `viewBox`, `fill`, `stroke`, `strokeWidth`, `strokeLinecap`, `strokeLinejoin`
- Add `aria-hidden="true"` on decorative icons
- Common sizes: 16px (small), 20px (medium), 24px (large)

## React Router Patterns

### Version & Stability
- **Recommended version**: `react-router-dom@6.28.0` (stable v6, not v7)
- React Router v7's `createBrowserRouter` can have issues with nested route re-renders, especially with context providers
- Prefer standard `BrowserRouter` with `<Outlet />` within layout components over `createBrowserRouter`

### Nested Route Structure
- Define parent routes that render layout components (e.g., `AdminLayout`, `MainLayout`)
- Use `<Outlet />` **within** layout components to render child routes
- **Never** pass `<Outlet />` as children to layout components—layouts should render it internally:
  ```tsx
  // ✓ Correct: Outlet inside layout
  const AdminLayout = () => (
    <div className="admin-layout">
      <AdminSidebar />
      <main><Outlet /></main>
    </div>
  );

  // Route config
  <Route path="/admin" element={<AdminLayout />}>
    <Route index element={<AdminDashboard />} />
    <Route path="users" element={<UsersList />} />
  </Route>
  ```

### Forcing Re-renders on Route Changes
- If `Outlet` or components aren't re-rendering correctly on nested route changes, add `key={location.pathname}` to force remount:
  ```tsx
  const location = useLocation();
  return <Outlet key={location.pathname} />;
  ```
- This is especially useful when route changes within nested routes don't trigger expected updates

## Admin Portal Patterns

### Codebase Separation
- Maintain strict separation between admin (CRM-like) and customer-facing application code:
  - **Routing**: `/admin/*` vs `/` for customer app
  - **Layouts**: `AdminLayout` vs `MainLayout`
  - **CSS**: Separate stylesheets for admin vs customer UI
  - **Contexts**: Separate where applicable; shared contexts (Auth, Organization) are acceptable when logically required

### Admin Navigation UX
- **Clickable table rows**: Make entire rows clickable for better UX and keyboard navigation
- **Hover/active states**: Implement clear visual feedback for interactive elements
- **Breadcrumbs**: Add breadcrumbs to detail and creation pages for orientation
- **Active link feedback**: Ensure navigation links have clear visual feedback when active

### Dev Mode Mocking for Admin
- In development, mock data in contexts (like `OrganizationContext`) should simulate necessary states:
  ```tsx
  // Mock super admin access for testing
  const mockUser = {
    ...baseUser,
    is_super_admin: import.meta.env.DEV ? true : user.is_super_admin
  };
  ```
- This enables testing of admin-specific features without full backend setup

## Sidebar & Mobile Navigation Implementation
- Sidebar collapse: Uses CSS class `.collapsed` toggled by JavaScript state and prop from `MainLayout`
- Mobile navigation: Combines `position: fixed` sidebar (off-screen by default), overlay, and hamburger button in fixed mobile header
- Clicking nav items in mobile drawer should close the drawer

## Mistakes to Avoid
- Initial state defaulting: Set correct initial values for toggles (e.g., `useState(false)` for collapsed-by-default)
- Overly broad active states: Use NavLink `end` prop to avoid unintended highlighting on child routes
- Redundant navigation: Don't create duplicate entry points; keep workflows clear (e.g., Publisher accessed only after generation)
- Hidden overlay click interception: `opacity: 0` does NOT prevent click events. Always add `pointer-events: none` to hidden overlays to prevent them from blocking interactions with elements beneath
- Inconsistent breakpoints: Standardize media query breakpoints across the codebase (900px for tablet, 600px for mobile)
- **Wrong API endpoint**: Dashboard metrics must come from `/api/funnel/metrics` (Supabase), NOT the Meta API. Using the wrong data source leads to zero/incorrect data
- **Missing type-only imports**: When `verbatimModuleSyntax` is enabled, failing to use `import type` for types causes build failures
- **React Router v7 instability**: Avoid `createBrowserRouter` (v7 API) with nested routes and context providers—use standard `BrowserRouter` with `<Outlet />` in layouts instead
- **Stale search params**: When using `useSearchParams` for initial state, clear the params after reading to avoid stale behavior on re-renders
- **Passing Outlet as children**: Never pass `<Outlet />` as children to layout components; layouts should render `<Outlet />` internally

### Stripe Integration Mistakes
- **Don't call `stripe.redirectToCheckout` without a session**: Always create a Checkout Session via backend API first, then pass the `sessionId` to `redirectToCheckout`
- **Don't expose secret keys**: Stripe secret key (`sk_*`) must only be used in backend serverless functions, never in frontend code
- **Don't skip configuration checks**: Always check `isStripeConfigured()` before attempting Stripe operations to handle gracefully when keys are missing

## Git Workflow
- Use descriptive commit messages summarizing actual changes
- `gh pr create` for automated PR creation
- Always check `git status` and `git diff` before committing

## Best Practices for Larger Tasks
- **Phased implementation**: Break responsiveness/layout tasks into phases (Core Layout, Page-Level, Component-Level, Polish)
- **Plan documentation**: Document goals, specific file changes, and verification checklist before coding
- **Test across viewports**: Use Chrome DevTools to test at various breakpoints (desktop, tablet, mobile)

## Component Structure
- Each component should have both a `.tsx` and corresponding `.css` file (e.g., `UserProfileDropdown.tsx` + `UserProfileDropdown.css`)
- Clear component separation promotes modularity: `Sidebar`, `MainLayout`, `ProtectedRoute`, `UserProfileDropdown`, etc.
- Use meaningful class names (e.g., `sidebar-collapsed`, `nav-item-expandable`, `mobile-menu-btn`)

## Demo Stubbing Patterns
- Use `localStorage` for authentication state (`'convertra_authenticated'`, `'convertra_user'`)
- Use `setTimeout` to simulate API calls in `Login.tsx` and `Register.tsx`
- Use context mocking for admin/permission states (e.g., `is_super_admin: true` in dev mode)
- Check `import.meta.env.DEV` for dev-only behavior
- These stubs enable quick demonstrations without a full backend

## localStorage Persistence Patterns
- **User preferences**: Store user-configurable values like ad spend, dashboard layout in localStorage
- **State initialization**: Use lazy initialization to load from localStorage:
  ```tsx
  const [value, setValue] = useState(() => {
    const saved = localStorage.getItem('key');
    return saved ? parseFloat(saved) : defaultValue;
  });
  ```
- **Dashboard customization**: Store selected metrics and layout order for persistence across sessions
- **Common keys**: `'dashboard_ad_spend'`, `'dashboard_metrics'`, `'dashboard_layout'`

## API Route Conventions
- Backend API routes live in `api/[feature_area]/[specific_route].ts`
- Use `@vercel/node` types (`VercelRequest`, `VercelResponse`) for serverless functions
- Frontend calls backend via `fetch('/api/[feature]/[action]')`
- Always return JSON responses with consistent error shapes

## External Library Patterns
- **Lazy-loading**: For heavy third-party libraries (Stripe.js, etc.), use lazy initialization pattern:
  ```typescript
  let libPromise: Promise<Lib | null> | null = null;
  export const getLib = () => {
    if (!libPromise) { libPromise = loadLib(config); }
    return libPromise;
  };
  ```
- **Configuration guards**: Always provide `isConfigured()` helpers that check env vars before attempting operations
- **Fallback data**: Provide `getDefaultData()` functions for graceful degradation when APIs are unavailable

## Data Formatting Standards
- **Currency**: Use `Intl.NumberFormat` for consistent, localized currency display:
  ```tsx
  new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(value)
  ```
- **Numbers**: Use `Intl.NumberFormat` for large numbers with proper separators
- **Percentages**: Format as `value.toFixed(2)%` for metrics like CVR, CTR

## Drag-and-Drop Implementation
- **Library**: Use `@dnd-kit` for modern drag-and-drop functionality
- **Common imports**: `DndContext`, `closestCenter`, `SortableContext`, `useSortable`, `arrayMove`
- **Type imports**: `import type { DragEndEvent }` (must be type-only import)
- **Pattern**: Wrap sortable items in `SortableContext`, use `useSortable` hook in child components

## AI API Integration Patterns

### Model Configuration
- **Centralize model IDs**: Define model IDs and API URLs as constants at the top of service files (e.g., `src/services/openaiApi.ts`)
  ```typescript
  const OPENAI_MODEL = 'gpt-5.2';
  const GEMINI_MODEL = 'gemini-3-pro-image-preview';
  ```
- **Feature flags**: Use boolean constants to switch between API providers
  ```typescript
  const USE_GEMINI_FOR_IMAGES = true;
  ```

### API Key Validation
- Check env vars for existence and length before use
- Provide specific error feedback: "Key rejected", "Key expired", "Model not found" rather than generic "API error"
- Consider creating diagnostic tools to help verify API key validity and model accessibility

### Error Handling for AI APIs
- Parse error messages from API responses for user-friendly feedback
- Implement progressive fallbacks to older/alternative models if newer ones fail
- Show clear loading states with accurate timing estimates during AI operations

### OpenAI GPT-5.2 Reasoning
- Use `reasoning.effort` parameter for depth control: `none`, `low`, `medium`, `high`, `xhigh`
- Higher effort = more tokens = increased API costs
- Request format: `{ reasoning: { effort: "medium" } }`

### Image Generation Limitations
- Some image URLs (e.g., Facebook CDN) may require authentication that AI APIs cannot handle
- Consider proxying or caching images locally before sending to AI APIs

## AI API Mistakes to Avoid
- **Don't hardcode model IDs**: Use centralized constants defined at service layer
- **Don't assume model ID accuracy**: Verify model IDs exist via API calls or documentation before implementing
- **Don't provide generic API errors**: Parse and surface specific error reasons to users
- **Don't skip configuration checks**: Always verify API keys are present and valid before operations
