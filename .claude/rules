# Development Workflow Rules

## Dev Server Management
- When the dev server port is in use, try alternative ports (5176, 5177, etc.)
- Always verify which workspace a running dev server belongs to before assuming changes are visible
- Check the `cwd` (current working directory) of running processes when debugging

## Troubleshooting Steps
- For visual changes not appearing: suggest hard refresh (Cmd+Shift+R / Ctrl+Shift+R)
- Browser caching is a common cause of "changes not visible" issues
- Before concluding a change failed, verify the correct server is running for this workspace

## Communication Patterns
- When making visual/styling changes, explicitly state what changed and the file/line number
- After visual changes, offer to adjust if styling intensity needs tweaking
- Guide users through troubleshooting steps to empower self-resolution
- **Simplify technical explanations**: Avoid jargon like "cloning the repo" without explanation; break down issues into simple, direct terms with clear examples of what is wrong and what is correct
- **Table format for fixes**: When presenting multiple fixes across files, use a table format clearly outlining the file, the issue, and the fix for maximum clarity

## TypeScript Patterns
- **Type-only imports**: Use `import type { MyType }` for types when using `verbatimModuleSyntax` to avoid runtime import overhead and build failures
  - Common types requiring `import type`: `ReactNode`, `MetricConfig`, `DragEndEvent`, `VercelRequest`, `VercelResponse`
  - Build will fail if regular imports are used for types with `verbatimModuleSyntax` enabled
- **Non-null assertions**: Use `process.env.VAR_NAME!` in serverless functions where env vars are guaranteed to exist
- **Strict typing for API responses**: Define interfaces for all API response shapes in `src/types/`

## Vite Dev Server Gotchas
- **esbuild URL parsing**: Vite's `esbuild` plugin can misinterpret URL query parameters containing ISO date strings (especially with milliseconds like `.000`) as loader values, causing internal server errors. Avoid passing raw ISO timestamps in URL query strings during development.

## Peer Dependency Management

### React 19 Compatibility
- Some libraries (e.g., `react-helmet-async`) expect React <19 and may cause peer dependency conflicts
- **Local fix**: Use `npm install --legacy-peer-deps` for installations
- **Vercel deployment fix**: Create `.npmrc` file with `legacy-peer-deps=true`
- Vercel's build process is stricter than local npm about peer dependencies

### Proactive Configuration
- For projects using React 19, proactively set up `.npmrc` with `legacy-peer-deps=true` to prevent deployment headaches
- Always verify `npm run build` succeeds both locally AND on deployment platform

## React Patterns Used in This Codebase
- Conditional rendering: `condition ? (...) : (...)` for show/hide
- NavLink with automatic `.active` class styling for navigation
- NavLink `end` prop: Use on parent routes (e.g., `/dashboard`) to prevent active state on child routes
- useState for toggles: Manage expanded/collapsed states (e.g., `channelsExpanded`, `insightsExpanded`)
- useEffect for data fetching on component mount
- useEffect for side effects: Manage body overflow when mobile nav is open, close mobile nav on route changes
- useLocation for route change triggers: Detect route changes to trigger side effects (e.g., closing mobile nav)
- Array.reduce() for aggregating campaign statistics
- `collapsed` prop propagation: Pass down to child components for consistent collapsed sidebar behavior
- Flexbox for sidebar and navigation layouts
- `overflow-y: auto` for scrollable navigation content
- Dynamic class toggling: Classes like `sidebar-collapsed`, `expanded`, `mobile-open` toggled in `.tsx`, defined in `.css`
- **useMemo and useCallback**: Use to prevent unnecessary re-renders when passing objects/functions as props or dependencies
- **useRef for non-render values**: Use `useRef` for mutable values that shouldn't trigger re-renders (instance IDs, DOM refs, cancel flags)
- **Unique keys for lists**: Always use stable, unique `key={item.id}` for list items to help React's reconciliation
- **useRef for IntersectionObserver**: Use `useRef` for managing IntersectionObserver instances for scroll-triggered animations without re-renders
- **useEffect cleanup for event listeners**: Always return cleanup functions for scroll events, intersection observers, and click listeners
- **useSearchParams cleanup**: When reading from `useSearchParams` for initial state, clear the params after consumption to prevent stale data on subsequent renders:
  ```tsx
  const [searchParams, setSearchParams] = useSearchParams();
  useEffect(() => {
    const initialValue = searchParams.get('value');
    if (initialValue) {
      // Use the value...
      searchParams.delete('value');
      setSearchParams(searchParams, { replace: true });
    }
  }, []);
  ```

## SVG Icon Conventions
- Use inline SVGs for icons (not icon fonts or separate image files)
- Standard attributes: `viewBox`, `fill`, `stroke`, `strokeWidth`, `strokeLinecap`, `strokeLinejoin`
- Add `aria-hidden="true"` on decorative icons
- Common sizes: 16px (small), 20px (medium), 24px (large)

## React Router Patterns

### Version & Stability
- **Recommended version**: `react-router-dom@6.28.0` (stable v6, not v7)
- React Router v7's `createBrowserRouter` can have issues with nested route re-renders, especially with context providers
- Prefer standard `BrowserRouter` with `<Outlet />` within layout components over `createBrowserRouter`

### Nested Route Structure
- Define parent routes that render layout components (e.g., `AdminLayout`, `MainLayout`)
- Use `<Outlet />` **within** layout components to render child routes
- **Never** pass `<Outlet />` as children to layout componentsâ€”layouts should render it internally:
  ```tsx
  // âœ“ Correct: Outlet inside layout
  const AdminLayout = () => (
    <div className="admin-layout">
      <AdminSidebar />
      <main><Outlet /></main>
    </div>
  );

  // Route config
  <Route path="/admin" element={<AdminLayout />}>
    <Route index element={<AdminDashboard />} />
    <Route path="users" element={<UsersList />} />
  </Route>
  ```

### Forcing Re-renders on Route Changes
- If `Outlet` or components aren't re-rendering correctly on nested route changes, add `key={location.pathname}` to force remount:
  ```tsx
  const location = useLocation();
  return <Outlet key={location.pathname} />;
  ```
- This is especially useful when route changes within nested routes don't trigger expected updates

## Admin Portal Patterns

### Codebase Separation
- Maintain strict separation between admin (CRM-like) and customer-facing application code:
  - **Routing**: `/admin/*` vs `/` for customer app
  - **Layouts**: `AdminLayout` vs `MainLayout`
  - **CSS**: Separate stylesheets for admin vs customer UI
  - **Contexts**: Separate where applicable; shared contexts (Auth, Organization) are acceptable when logically required

### Admin Navigation UX
- **Clickable table rows**: Make entire rows clickable for better UX and keyboard navigation
- **Hover/active states**: Implement clear visual feedback for interactive elements
- **Breadcrumbs**: Add breadcrumbs to detail and creation pages for orientation
- **Active link feedback**: Ensure navigation links have clear visual feedback when active

### Dev Mode Mocking for Admin
- In development, mock data in contexts (like `OrganizationContext`) should simulate necessary states:
  ```tsx
  // Mock super admin access for testing
  const mockUser = {
    ...baseUser,
    is_super_admin: import.meta.env.DEV ? true : user.is_super_admin
  };
  ```
- This enables testing of admin-specific features without full backend setup

## Sidebar & Mobile Navigation Implementation
- Sidebar collapse: Uses CSS class `.collapsed` toggled by JavaScript state and prop from `MainLayout`
- Mobile navigation: Combines `position: fixed` sidebar (off-screen by default), overlay, and hamburger button in fixed mobile header
- Clicking nav items in mobile drawer should close the drawer

## SEO & GEO Patterns

### SEO in Single Page Applications (SPAs)
- Use `react-helmet-async` for managing `<head>` tags in client-side rendered React apps
- Create a dedicated `SEO.tsx` component to centralize meta tags, structured data, and SEO elements
- All pages (including Login, Register, Dashboard) should have basic meta tags; use `noindex` for internal pages

### GEO (Generative Engine Optimization)
- Optimize for AI citations alongside traditional SEO
- Key elements for AI citation: clear definitions, quotable statistics, Q&A formats, authority signals, structured data
- Allow AI bots explicitly in `robots.txt`: GPTBot, Claude-Web, PerplexityBot, Google-Extended

### Schema Markup
- Use JSON-LD format for structured data (modern standard, well-supported by search engines and AI)
- Validate schema with Google's Rich Results Test or Schema.org Validator before deployment

### SEO File Locations
- `robots.txt` â†’ `public/robots.txt`
- `sitemap.xml` â†’ `public/sitemap.xml`
- SEO component â†’ `src/components/SEO.tsx`

## Meta API Patterns

### Page Access Validation
- **Use `promote_pages` from the Ad Account, not `promotable_posts` from the Page**: To validate ad creation permissions, query `/{ad_account_id}/promote_pages` (Ad Account perspective), not `/{page_id}/promotable_posts` (Page perspective). The `promotable_posts` endpoint is unreliable for permission validation.
- **Progressive validation**: Check Page readability first, then ad creation permissions as a secondary step. If the secondary check fails, log a warning and continue rather than blocking.
- **Diagnostic error responses**: When Meta API calls fail, return the specific error code, message, and actionable diagnostic stepsâ€”not just a generic failure message.

## Mistakes to Avoid
- Initial state defaulting: Set correct initial values for toggles (e.g., `useState(false)` for collapsed-by-default)
- Overly broad active states: Use NavLink `end` prop to avoid unintended highlighting on child routes
- Redundant navigation: Don't create duplicate entry points; keep workflows clear (e.g., Publisher accessed only after generation)
- Hidden overlay click interception: `opacity: 0` does NOT prevent click events. Always add `pointer-events: none` to hidden overlays to prevent them from blocking interactions with elements beneath
- **`mousedown` for click-outside handlers**: Using `mousedown` to detect clicks outside a dropdown can interfere with `onClick` events on dropdown items, causing them to not register. Use `mousedown` with `preventDefault` carefully, or use `click` events with proper event ordering
- Inconsistent breakpoints: Standardize media query breakpoints across the codebase (900px for tablet, 600px for mobile)
- **Wrong API endpoint**: Dashboard metrics must come from `/api/funnel/metrics` (Supabase), NOT the Meta API. Using the wrong data source leads to zero/incorrect data
- **Missing type-only imports**: When `verbatimModuleSyntax` is enabled, failing to use `import type` for types causes build failures
- **React Router v7 instability**: Avoid `createBrowserRouter` (v7 API) with nested routes and context providersâ€”use standard `BrowserRouter` with `<Outlet />` in layouts instead
- **Stale search params**: When using `useSearchParams` for initial state, clear the params after reading to avoid stale behavior on re-renders
- **Passing Outlet as children**: Never pass `<Outlet />` as children to layout components; layouts should render `<Outlet />` internally
- **Unused imports causing build failures**: Remove unused imports before committing, especially when commenting out code that used them (e.g., `StrictMode` in `main.tsx`). TypeScript strict mode will fail the build on unused declared variables
- **Deploying without peer dependency resolution**: Committing changes to Vercel without ensuring local dependency resolution methods (`--legacy-peer-deps`) are also applied in the deployment environment (`.npmrc`) causes build failures
- **Overlooking app pages for SEO**: When adding SEO, don't focus only on the main landing page. All pages (Login, Register, Dashboard) benefit from basic meta tags; internal pages should use `noindex` directives
- **Not testing schema with validators**: Validate structured data with Google's Rich Results Test or Schema.org Validator before deployment to catch issues early
- **Incomplete documentation fixes**: Fixing an issue in one documentation file but missing other files with the same underlying problem leads to repeated user frustration (e.g., only updating `SETUP.md` while missing other documentation files)
- **Assuming folder structure**: Do not assume a standard folder structure within a cloned Git repositoryâ€”always verify the actual project root and subfolder structure by inspecting the file system
- **Overlooking port numbers**: Consistently check and update port numbers across ALL relevant documentation and configuration files (e.g., `5173` vs. `5175`)

### Meta API Publishing Mistakes
- **Assuming token validity from partial success**: A token may work for reading ads/analytics but lack scopes for publishing (`pages_manage_ads`, `pages_read_engagement`). Always re-validate permissions before publish operations
- **Missing Page ID**: `VITE_META_PAGE_ID` is required for ad publishing via `object_story_spec`. Omitting it causes cryptic API errors
- **Not creating ads as PAUSED**: Always create ads with `status: 'PAUSED'` to prevent accidental live publication
- **Skipping pre-validation**: Always run `validatePageAccess` (Step 0) before the full publish flow to catch permission and configuration issues early with specific diagnostics
- **Using deprecated API fields**: Meta deprecates fields silently. `approximate_count` â†’ `approximate_count_lower_bound`/`approximate_count_upper_bound`. Always verify current field names.
- **Swallowing Meta API errors**: Meta's APIs often return `[]` on error instead of throwing. Never let API wrappers catch errors and return empty arrays without surfacing the error to the user.
- **Not providing retry for API-fetched data**: Always add a "Refresh" button for data fetched from external APIs (custom audiences, targeting suggestions) so users can manually retry on failure

### Stripe Integration Mistakes
- **Don't call `stripe.redirectToCheckout` without a session**: Always create a Checkout Session via backend API first, then pass the `sessionId` to `redirectToCheckout`
- **Don't expose secret keys**: Stripe secret key (`sk_*`) must only be used in backend serverless functions, never in frontend code
- **Don't skip configuration checks**: Always check `isStripeConfigured()` before attempting Stripe operations to handle gracefully when keys are missing

## Git Workflow
- Use descriptive commit messages summarizing actual changes; mention PR number if applicable
- `gh pr create` for automated PR creation
- Always check `git status` and `git diff` before committing
- **Build verification**: Always run `npm run build` before committing to catch TypeScript errors (unused variables, type mismatches) that would fail Vercel deployment
- **Leverage Git history**: When a fix was made on another branch, consult Git history (commit messages, diffs) to understand what was changed and identify any incomplete parts
- **Branch/deployment alignment**: Vercel deploys from `main`. Ensure fixes are merged to the correct branch; pushing to a feature branch that isn't deployed won't fix production issues
- **Symlinked `.env`**: The `.env` file may be a symlinkâ€”changes may need to target the symlink's actual file, not the symlink itself

## Documentation Consistency
- **Update all related files**: When fixing issues in setup scripts or documentation, ensure ALL related files are updated consistently (e.g., `SETUP.md`, `APP-README.md`, `UPDATE-YOUR-LOCAL-COPY.md`, `WHAT-YOU-SHOULD-SEE.md`)
- **Paths, ports, and branch names**: These are recurring sources of confusionâ€”verify consistency across all documentation files
- **Don't fix partially**: Fixing only one documentation file while leaving others outdated leads to repeated user frustration

## File System Inspection
- **Verify before fixing**: Before making fixes, thoroughly inspect the project's directory structure to understand the actual layout
- **Don't assume folder structure**: Do not assume a standard folder structure within a cloned Git repositoryâ€”always verify the actual project root and subfolder locations
- **Check for related files**: When addressing a documentation or setup issue, search for ALL files that might need the same update

## Best Practices for Larger Tasks
- **Phased implementation**: Break responsiveness/layout tasks into phases (Core Layout, Page-Level, Component-Level, Polish)
- **Plan documentation**: Document goals, specific file changes, and verification checklist before coding
- **Test across viewports**: Use Chrome DevTools to test at various breakpoints (desktop, tablet, mobile)

## Component Structure
- Each component should have both a `.tsx` and corresponding `.css` file (e.g., `UserProfileDropdown.tsx` + `UserProfileDropdown.css`)
- Clear component separation promotes modularity: `Sidebar`, `MainLayout`, `ProtectedRoute`, `UserProfileDropdown`, etc.
- Use meaningful class names (e.g., `sidebar-collapsed`, `nav-item-expandable`, `mobile-menu-btn`)

## Demo Stubbing Patterns
- Use `localStorage` for authentication state (`'convertra_authenticated'`, `'convertra_user'`)
- Use `setTimeout` to simulate API calls in `Login.tsx` and `Register.tsx`
- Use context mocking for admin/permission states (e.g., `is_super_admin: true` in dev mode)
- Check `import.meta.env.DEV` for dev-only behavior
- These stubs enable quick demonstrations without a full backend

## localStorage Persistence Patterns
- **User preferences**: Store user-configurable values like ad spend, dashboard layout in localStorage
- **State initialization**: Use lazy initialization to load from localStorage:
  ```tsx
  const [value, setValue] = useState(() => {
    const saved = localStorage.getItem('key');
    return saved ? parseFloat(saved) : defaultValue;
  });
  ```
- **Dashboard customization**: Store selected metrics and layout order for persistence across sessions
- **Common keys**: `'dashboard_ad_spend'`, `'dashboard_metrics'`, `'dashboard_layout'`

## Meta API Permissions & Token Management

### Required Scopes by Operation
| Operation | Required Scopes |
|-----------|----------------|
| Read campaigns, ad sets, ads | `ads_read` |
| Create campaigns, ad sets | `ads_management`, `ads_read` |
| Create ad creatives (with `object_story_spec`) | `ads_management`, `pages_read_engagement`, `pages_manage_ads` |
| Publish to a Page | `pages_manage_ads`, `pages_read_engagement` |

### Token Types
- **System User tokens**: Can have `expires_at: 0` (never expire) but still require specific granular scopes like `pages_manage_ads`
- **User tokens**: Have expiration dates and require appropriate scopes

### Pre-Publish Validation
- Always run `validatePageAccess` before attempting to publish ads
- This checks: token validity, Page ID configuration, and required permissions
- Provides specific diagnostic messages (e.g., "Set VITE_META_PAGE_ID", "Generate a new token with pages_manage_ads scope")

### Token Caching Pitfall
- A valid-looking UI may persist with an expired or insufficient token due to client-side caching of previously fetched data
- The Meta API will reject new write requests even if cached read data still displays correctly

## API Route Conventions
- Backend API routes live in `api/[feature_area]/[specific_route].ts`
- Use `@vercel/node` types (`VercelRequest`, `VercelResponse`) for serverless functions
- Frontend calls backend via `fetch('/api/[feature]/[action]')`
- Always return JSON responses with consistent error shapes

## External Library Patterns
- **Lazy-loading**: For heavy third-party libraries (Stripe.js, etc.), use lazy initialization pattern:
  ```typescript
  let libPromise: Promise<Lib | null> | null = null;
  export const getLib = () => {
    if (!libPromise) { libPromise = loadLib(config); }
    return libPromise;
  };
  ```
- **Configuration guards**: Always provide `isConfigured()` helpers that check env vars before attempting operations
- **Fallback data**: Provide `getDefaultData()` functions for graceful degradation when APIs are unavailable

## Data Formatting Standards
- **Currency**: Use `Intl.NumberFormat` for consistent, localized currency display:
  ```tsx
  new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(value)
  ```
- **Numbers**: Use `Intl.NumberFormat` for large numbers with proper separators
- **Percentages**: Format as `value.toFixed(2)%` for metrics like CVR, CTR

## Drag-and-Drop Implementation
- **Library**: Use `@dnd-kit` for modern drag-and-drop functionality
- **Common imports**: `DndContext`, `closestCenter`, `SortableContext`, `useSortable`, `arrayMove`
- **Type imports**: `import type { DragEndEvent }` (must be type-only import)
- **Pattern**: Wrap sortable items in `SortableContext`, use `useSortable` hook in child components

## AI API Integration Patterns

### Model Configuration
- **Centralize model IDs**: Define model IDs and API URLs as constants at the top of service files (e.g., `src/services/openaiApi.ts`)
  ```typescript
  const OPENAI_MODEL = 'gpt-5.2';
  const GEMINI_MODEL = 'gemini-3-pro-image-preview';
  ```
- **Feature flags**: Use boolean constants to switch between API providers
  ```typescript
  const USE_GEMINI_FOR_IMAGES = true;
  ```

### API Key Validation
- Check env vars for existence and length before use
- Provide specific error feedback: "Key rejected", "Key expired", "Model not found" rather than generic "API error"
- Consider creating diagnostic tools to help verify API key validity and model accessibility

### Error Handling for AI APIs
- Parse error messages from API responses for user-friendly feedback
- Implement progressive fallbacks to older/alternative models if newer ones fail
- Show clear loading states with accurate timing estimates during AI operations
- Handle rate-limiting errors (`429`) gracefully with retry logic or user feedback
- **Robust JSON error parsing**: Wrap error JSON parsing in try-catch to handle malformed responses:
  ```typescript
  try {
    const errorData = await response.json();
    throw new Error(errorData.error?.message || 'API request failed');
  } catch (parseError) {
    throw new Error(`API error: ${response.status} ${response.statusText}`);
  }
  ```
- Add logging statements to track model calls, reasoning effort, and image processing for debugging
- Use emoji prefixes for visual log categorization (e.g., `ðŸŽ¨ Generating ad image...`, `ðŸ¤– Calling GPT-5.2...`, `âœ… Generation complete`)

### Robust API Response Handling
- API responses can vary in structure; always validate expected fields exist:
  ```typescript
  // For image generation APIs, check all levels of nesting
  const candidates = response.candidates;
  if (!candidates?.[0]?.content?.parts?.[0]?.inlineData) {
    throw new Error('Unexpected API response structure');
  }
  ```
- Use optional chaining (`?.`) to safely access nested properties
- Provide fallback values or clear error messages when expected data is missing

### OpenAI GPT-5.2 Reasoning
- Use `reasoning.effort` parameter for depth control: `none`, `low`, `medium`, `high`, `xhigh`
- Higher effort = more tokens = increased API costs
- Request format: `{ reasoning: { effort: "medium" } }`
- **Vision API limitation**: The `reasoning` parameter is NOT supported by the Vision API, even for models that support it in text-only mode

### OpenAI API Parameter Evolution
- Use `max_completion_tokens` instead of `max_tokens` for newer OpenAI models/endpoints
- Different OpenAI endpoints (chat vs. vision) may support different parameters
- Always check endpoint-specific documentation for supported parameters

### Image Generation Limitations
- Some image URLs (e.g., Facebook CDN) may require authentication that AI APIs cannot handle
- Consider proxying or caching images locally before sending to AI APIs

### Structured API Configuration Constants
Define image/media options as typed constants for maintainability:
```typescript
const IMAGE_SIZE_OPTIONS = {
  square: { label: '1:1 Square', aspectRatio: '1:1', width: 1024, height: 1024, dalleSize: '1024x1024' },
  landscape: { label: '16:9 Landscape', aspectRatio: '16:9', width: 1792, height: 1024, dalleSize: '1792x1024' },
  portrait: { label: '9:16 Portrait', aspectRatio: '9:16', width: 1024, height: 1792, dalleSize: '1024x1792' },
} as const;

type ImageSize = keyof typeof IMAGE_SIZE_OPTIONS;
```
This pattern centralizes dimensions, aspect ratios, and API-specific parameters in one place.

### Gemini API Parameter Structure
The Gemini Imagen API requires specific parameter nesting:
```typescript
// âœ“ Correct: aspectRatio inside generationConfig
{
  contents: [{ parts: [{ text: prompt }] }],
  generationConfig: {
    responseModalities: ['TEXT', 'IMAGE'],
    aspectRatio: '1:1'  // Must be inside generationConfig
  }
}

// âœ— Wrong: aspectRatio outside generationConfig
{
  contents: [...],
  aspectRatio: '1:1',  // Causes 400 Bad Request
  generationConfig: { ... }
}
```
Valid aspect ratios: `"1:1"`, `"16:9"`, `"9:16"`, `"4:3"`, `"3:4"`. Non-standard ratios like `"1.91:1"` are not supported.

## AI API Mistakes to Avoid
- **Don't hardcode model IDs**: Use centralized constants defined at service layer
- **Don't assume model ID accuracy**: Verify model IDs exist via API calls or documentation before implementing
- **Don't provide generic API errors**: Parse and surface specific error reasons to users
- **Don't skip configuration checks**: Always verify API keys are present and valid before operations
- **Don't assume parameter universality**: Parameters supported by one endpoint (e.g., `reasoning` for chat) may not work on another (e.g., vision API)
- **Don't do incomplete API scans**: When fixing an API parameter issue, check ALL related API functions (e.g., `callOpenAI` AND `callOpenAIWithVision`), not just the one that triggered the error
- **Don't skip build checks**: Always run `npm run build` or TypeScript checks after API-related modifications to catch regressions
- **Don't mix image API parameters**: Gemini uses `aspectRatio`, DALL-E uses `size` - using wrong parameter for wrong API yields unexpected dimensions
- **Don't assume API response structure**: Always validate that `candidates`, `parts`, `inlineData` exist before accessing
- **Don't misplace Gemini parameters**: `aspectRatio` must be inside `generationConfig`, not at the root levelâ€”incorrect placement causes 400 Bad Request errors

## React StrictMode & Async Operations

React's StrictMode causes components to render twice in development. Combined with async data loading and localStorage, this can lead to duplicate rendering or mounting issues.

### Mitigation Patterns
- **mountedRef pattern**: Track component mount state to prevent state updates after unmount:
  ```tsx
  const mountedRef = useRef(true);
  useEffect(() => {
    return () => { mountedRef.current = false; };
  }, []);

  // In async callbacks:
  if (mountedRef.current) {
    setData(result);
  }
  ```
- **isCancelled flag for async cleanup**: Use a local flag in effects to prevent state updates after cleanup:
  ```tsx
  useEffect(() => {
    let isCancelled = false;
    const fetchData = async () => {
      const result = await apiCall();
      if (!isCancelled) setData(result);
    };
    fetchData();
    return () => { isCancelled = true; };
  }, [dependency]);
  ```
- **clearTimeout cleanup**: Always clear timeouts in effect cleanup to prevent memory leaks:
  ```tsx
  useEffect(() => {
    const timer = setTimeout(() => { /* ... */ }, 1000);
    return () => clearTimeout(timer);
  }, []);
  ```
- **Unique keys for DOM cleanup**: Use `key={location.pathname}` or `data-instance` attributes to help React manage component instances correctly when duplicate rendering occurs
- **data-instance debugging**: Add `data-instance={instanceId}` attributes and render count logs to debug component lifecycle issues during development
- **Render counting for debugging**: Use `useRef` to count renders and identify infinite loops:
  ```tsx
  const renderCount = useRef(0);
  renderCount.current++;
  if (DEBUG_MODE) {
    console.log(`[ComponentName] Render #${renderCount.current}`);
  }
  ```
- **Deferred operations**: Use `requestIdleCallback` with `setTimeout` fallback to defer heavy operations:
  ```tsx
  const scheduleIdle = (callback: () => void) => {
    if ('requestIdleCallback' in window) {
      requestIdleCallback(callback);
    } else {
      setTimeout(callback, 0);
    }
  };
  ```
  This prevents UI freezes and race conditions during double-render

## localStorage Performance Patterns

Large amounts of data in localStorage can significantly impact performance, especially during synchronous JSON parsing which blocks the main thread.

### Browser Limitations
- Browsers have localStorage size limits (typically 5-10MB)
- Storing large data (especially base64 encoded images) can cause performance degradation, crashes, and `QuotaExceededError`
- Monitor storage usage and warn users when approaching limits
- Implement "Clear All" functionality for stored data (e.g., generated ads, cached images)

### Best Practices
- **Async parsing**: Parse large localStorage data asynchronously to prevent main thread blocking:
  ```tsx
  requestIdleCallback(() => {
    const data = JSON.parse(localStorage.getItem('large_key') || '[]');
    if (mountedRef.current) setData(data);
  });
  ```
- **Extract metadata first**: For large datasets, extract only necessary metadata initially; load full data (images, resources) only when strictly needed (e.g., at publish time, not during selection)
- **Size limits**: Implement limits on stored data (e.g., `MAX_VISIBLE_ADS` pattern) to prevent unbounded growth
- **Progressive loading**: For lists with many items, implement lazy loading or virtualization - render only visible items to prevent DOM bottlenecks
- **Feature flags for debugging**: Use flags like `SKIP_LOCALSTORAGE` or `DEBUG_MODE` to isolate localStorage-related issues:
  ```tsx
  const SKIP_LOCALSTORAGE = false; // Set to true to bypass localStorage during debugging
  const DEBUG_MODE = false; // Set to true for verbose logging
  ```

## Media Rendering Performance

Rendering many high-resolution images/videos on a single page causes significant performance issues and potential browser crashes due to memory consumption and rendering work.

### Lazy Loading Media Pattern
- Initially hide large media items; require user interaction to display:
  ```tsx
  const [showImage, setShowImage] = useState(false);

  return showImage ? (
    <img src={imageUrl} alt="..." />
  ) : (
    <button onClick={() => setShowImage(true)}>Show Image</button>
  );
  ```
- Use `IntersectionObserver` for viewport-based lazy loading
- For lists with many media items, implement pagination or virtualization
- Never render all base64-encoded images directly on page load

### Image Generation API Differences
- **Gemini**: Requires explicit `aspectRatio` in generation config (e.g., `"1:1"`, `"16:9"`)
- **DALL-E**: Uses `size` parameter (e.g., `"1024x1024"`, `"1792x1024"`)
- Both require correct dimension parameters for expected output

---

## Multi-Step Workflow Patterns

For complex generation or configuration workflows with multiple steps:

### State Management
- Break workflows into distinct steps (`config`, `selection`, `final-config`, `generate`)
- Use step indicator UI to show progress
- Pre-compute or cache intermediate results to avoid recalculation:
  ```tsx
  const [copyOptions, setCopyOptions] = useState<CopyOption[]>([]);

  // Compute once and cache
  useEffect(() => {
    const options = computeExpensiveOptions(sourceData);
    setCopyOptions(options);
  }, [sourceData]);
  ```

### Progress Feedback
- Track `generationProgress` state for multi-step operations
- Show clear status messages during each phase
- Use spinners and disabled states (`isGeneratingCopy`, `isGeneratingCreatives`)
- Provide specific progress text, not generic "Loading..."

---

## CSS Isolation & Performance

### Containment Properties
- **`isolation: isolate`**: Use on containers like `.main-content` to create new stacking contexts and prevent style bleed
- **`contain: layout style paint`**: Use on complex components to improve rendering performance by isolating layout recalculations

### Component-Scoped Selectors
- Use component-scoped class names to prevent global style conflicts:
  ```css
  /* Scoped to specific page */
  .ad-generator-page .step-indicator { ... }
  .publisher-steps .step-item { ... }
  ```
- Prefix page-specific styles with page class names to avoid unintended cascade effects
