# Development Workflow Rules

## Dev Server Management
- When the dev server port is in use, try alternative ports (5176, 5177, etc.)
- Always verify which workspace a running dev server belongs to before assuming changes are visible
- Check the `cwd` (current working directory) of running processes when debugging

## Troubleshooting Steps
- For visual changes not appearing: suggest hard refresh (Cmd+Shift+R / Ctrl+Shift+R)
- Browser caching is a common cause of "changes not visible" issues
- Before concluding a change failed, verify the correct server is running for this workspace

## Communication Patterns
- When making visual/styling changes, explicitly state what changed and the file/line number
- After visual changes, offer to adjust if styling intensity needs tweaking
- Guide users through troubleshooting steps to empower self-resolution

## TypeScript Patterns
- **Type-only imports**: Use `import type { MyType }` for types when using `verbatimModuleSyntax` to avoid runtime import overhead and build failures
  - Common types requiring `import type`: `ReactNode`, `MetricConfig`, `DragEndEvent`, `VercelRequest`, `VercelResponse`
  - Build will fail if regular imports are used for types with `verbatimModuleSyntax` enabled
- **Non-null assertions**: Use `process.env.VAR_NAME!` in serverless functions where env vars are guaranteed to exist
- **Strict typing for API responses**: Define interfaces for all API response shapes in `src/types/`

## React Patterns Used in This Codebase
- Conditional rendering: `condition ? (...) : (...)` for show/hide
- NavLink with automatic `.active` class styling for navigation
- NavLink `end` prop: Use on parent routes (e.g., `/dashboard`) to prevent active state on child routes
- useState for toggles: Manage expanded/collapsed states (e.g., `channelsExpanded`, `insightsExpanded`)
- useEffect for data fetching on component mount
- useEffect for side effects: Manage body overflow when mobile nav is open, close mobile nav on route changes
- useLocation for route change triggers: Detect route changes to trigger side effects (e.g., closing mobile nav)
- Array.reduce() for aggregating campaign statistics
- `collapsed` prop propagation: Pass down to child components for consistent collapsed sidebar behavior
- Flexbox for sidebar and navigation layouts
- `overflow-y: auto` for scrollable navigation content
- Dynamic class toggling: Classes like `sidebar-collapsed`, `expanded`, `mobile-open` toggled in `.tsx`, defined in `.css`

## SVG Icon Conventions
- Use inline SVGs for icons (not icon fonts or separate image files)
- Standard attributes: `viewBox`, `fill`, `stroke`, `strokeWidth`, `strokeLinecap`, `strokeLinejoin`
- Add `aria-hidden="true"` on decorative icons
- Common sizes: 16px (small), 20px (medium), 24px (large)

## Sidebar & Mobile Navigation Implementation
- Sidebar collapse: Uses CSS class `.collapsed` toggled by JavaScript state and prop from `MainLayout`
- Mobile navigation: Combines `position: fixed` sidebar (off-screen by default), overlay, and hamburger button in fixed mobile header
- Clicking nav items in mobile drawer should close the drawer

## Mistakes to Avoid
- Initial state defaulting: Set correct initial values for toggles (e.g., `useState(false)` for collapsed-by-default)
- Overly broad active states: Use NavLink `end` prop to avoid unintended highlighting on child routes
- Redundant navigation: Don't create duplicate entry points; keep workflows clear (e.g., Publisher accessed only after generation)
- Hidden overlay click interception: `opacity: 0` does NOT prevent click events. Always add `pointer-events: none` to hidden overlays to prevent them from blocking interactions with elements beneath
- Inconsistent breakpoints: Standardize media query breakpoints across the codebase (900px for tablet, 600px for mobile)
- **Wrong API endpoint**: Dashboard metrics must come from `/api/funnel/metrics` (Supabase), NOT the Meta API. Using the wrong data source leads to zero/incorrect data
- **Missing type-only imports**: When `verbatimModuleSyntax` is enabled, failing to use `import type` for types causes build failures

### Stripe Integration Mistakes
- **Don't call `stripe.redirectToCheckout` without a session**: Always create a Checkout Session via backend API first, then pass the `sessionId` to `redirectToCheckout`
- **Don't expose secret keys**: Stripe secret key (`sk_*`) must only be used in backend serverless functions, never in frontend code
- **Don't skip configuration checks**: Always check `isStripeConfigured()` before attempting Stripe operations to handle gracefully when keys are missing

## Git Workflow
- Use descriptive commit messages summarizing actual changes
- `gh pr create` for automated PR creation
- Always check `git status` and `git diff` before committing

## Best Practices for Larger Tasks
- **Phased implementation**: Break responsiveness/layout tasks into phases (Core Layout, Page-Level, Component-Level, Polish)
- **Plan documentation**: Document goals, specific file changes, and verification checklist before coding
- **Test across viewports**: Use Chrome DevTools to test at various breakpoints (desktop, tablet, mobile)

## Component Structure
- Each component should have both a `.tsx` and corresponding `.css` file (e.g., `UserProfileDropdown.tsx` + `UserProfileDropdown.css`)
- Clear component separation promotes modularity: `Sidebar`, `MainLayout`, `ProtectedRoute`, `UserProfileDropdown`, etc.
- Use meaningful class names (e.g., `sidebar-collapsed`, `nav-item-expandable`, `mobile-menu-btn`)

## Demo Stubbing Patterns
- Use `localStorage` for authentication state (`'convertra_authenticated'`, `'convertra_user'`)
- Use `setTimeout` to simulate API calls in `Login.tsx` and `Register.tsx`
- These stubs enable quick demonstrations without a full backend

## localStorage Persistence Patterns
- **User preferences**: Store user-configurable values like ad spend, dashboard layout in localStorage
- **State initialization**: Use lazy initialization to load from localStorage:
  ```tsx
  const [value, setValue] = useState(() => {
    const saved = localStorage.getItem('key');
    return saved ? parseFloat(saved) : defaultValue;
  });
  ```
- **Dashboard customization**: Store selected metrics and layout order for persistence across sessions
- **Common keys**: `'dashboard_ad_spend'`, `'dashboard_metrics'`, `'dashboard_layout'`

## API Route Conventions
- Backend API routes live in `api/[feature_area]/[specific_route].ts`
- Use `@vercel/node` types (`VercelRequest`, `VercelResponse`) for serverless functions
- Frontend calls backend via `fetch('/api/[feature]/[action]')`
- Always return JSON responses with consistent error shapes

## External Library Patterns
- **Lazy-loading**: For heavy third-party libraries (Stripe.js, etc.), use lazy initialization pattern:
  ```typescript
  let libPromise: Promise<Lib | null> | null = null;
  export const getLib = () => {
    if (!libPromise) { libPromise = loadLib(config); }
    return libPromise;
  };
  ```
- **Configuration guards**: Always provide `isConfigured()` helpers that check env vars before attempting operations
- **Fallback data**: Provide `getDefaultData()` functions for graceful degradation when APIs are unavailable

## Data Formatting Standards
- **Currency**: Use `Intl.NumberFormat` for consistent, localized currency display:
  ```tsx
  new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(value)
  ```
- **Numbers**: Use `Intl.NumberFormat` for large numbers with proper separators
- **Percentages**: Format as `value.toFixed(2)%` for metrics like CVR, CTR

## Drag-and-Drop Implementation
- **Library**: Use `@dnd-kit` for modern drag-and-drop functionality
- **Common imports**: `DndContext`, `closestCenter`, `SortableContext`, `useSortable`, `arrayMove`
- **Type imports**: `import type { DragEndEvent }` (must be type-only import)
- **Pattern**: Wrap sortable items in `SortableContext`, use `useSortable` hook in child components
